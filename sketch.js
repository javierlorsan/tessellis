let colors1 = ["#03045e", "#023e8a", "#0077b6", "#0096c7", "#00b4d8", "#48cae4", "#90e0ef", "#ade8f4", "#caf0f8", "#D9F1F6"];
let colors2 = ["#03071e", "#370617", "#6a040f", "#9d0208", "#d00000", "#dc2f02", "#e85d04", "#f48c06", "#faa307", "#F5B034"];
let colors3 = ["#ffba08", "#f8f9fa", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#6c757d", "#495057", "#343a40", "#212529"];
let colors4 = ["#001219", "#005f73", "#0a9396", "#94d2bd", "#e9d8a6", "#ee9b00", "#ca6702", "#bb3e03", "#ae2012", "#9b2226"];
let colors5 = ["#582f0e", "#7f4f24", "#936639", "#a68a64", "#b6ad90", "#c2c5aa", "#a4ac86", "#656d4a", "#414833", "#333d29"];
let colors6 = ["#10002b", "#240046", "#3c096c", "#5a189a", "#7b2cbf", "#9d4edd", "#c77dff", "#e0aaff", "#E3B9FB", "#D9C5E5"];
let colors7 = ["#590d22", "#800f2f", "#a4133c", "#c9184a", "#ff4d6d", "#ff758f", "#ff8fa3", "#ffb3c1", "#ffccd5", "#fff0f3"];
let colors8 = ["#ffedd8", "#f3d5b5", "#e7bc91", "#d4a276", "#bc8a5f", "#a47148", "#8b5e34", "#6f4518", "#603808", "#583101"];
let colors9 = ["#007f5f", "#2b9348", "#55a630", "#80b918", "#aacc00", "#bfd200", "#d4d700", "#dddf00", "#eeef20", "#ffff3f"];
let colors10 = ["#e8a598", "#ffb5a7", "#fec5bb", "#fcd5ce", "#fae1dd", "#f8edeb", "#f9e5d8", "#f9dcc4", "#fcd2af", "#fec89a"];
let colors11 = ["#ff0a54", "#ff477e", "#ff5c8a", "#ff7096", "#ff85a1", "#ff99ac", "#fbb1bd", "#f9bec7", "#f7cad0", "#fae0e4"];
let colors12 = ["#ff7b00", "#ff8800", "#ff9500", "#ffa200", "#ffaa00", "#ffb700", "#ffc300", "#ffd000", "#ffdd00", "#ffea00"];
let colors13 = ["#d8f3dc", "#b7e4c7", "#95d5b2", "#74c69d", "#52b788", "#40916c", "#2d6a4f", "#0C6A40", "#5A9077", "#5FD49D"];
let colors14 = ["#ff6d00", "#ff7900", "#ff8500", "#ff9100", "#ff9e00", "#240046", "#3c096c", "#5a189a", "#7b2cbf", "#9d4edd"];
let colors15 = ["#99e2b4", "#88d4ab", "#78c6a3", "#67b99a", "#56ab91", "#469d89", "#358f80", "#248277", "#14746f", "#036666"];
let colors16 = ["#757bc8", "#8187dc", "#8e94f2", "#9fa0ff", "#ada7ff", "#bbadff", "#cbb2fe", "#dab6fc", "#ddbdfc", "#e0c3fc"];
let colors17 = ["#7A5D41", "#C4B4A8", "#59ADCC", "#F9A50B", "#DDE3E1", "#A75506", "#2C5838", "#371A0A", "#739384", "#130C0B"];
let colors18 = ["#105F85", "#2C5838", "#7F7168", "#371A0A", "#F9A50B", "#A75506", "#59ADCC", "#C6A076", "#739384", "#89520E"];
let colors19 = ["#576A7C", "#16141A", "#553920", "#82624C", "#B8B2AE", "#774B24", "#ECEDEA", "#BFC4CC", "#DCD8D1", "#8AAFC7"];
let colors20 = ["#8AAFC7", "#BFC4CC", "#A09083", "#774B24", "#585150", "#D1CAC4", "#DCD8D1", "#82624C", "#D8DBE1", "#8198A5"];
let colors21 = ["#8AAFC7", "#553920", "#A09083", "#585150", "#16141A", "#82624C", "#BFC4CC", "#493D3B", "#576A7C", "#100908"];
let colors22 = ["#AD666A", "#A28471", "#CC8F75", "#4B4F51", "#3F3236", "#48403D", "#CE9292", "#70625D", "#191312", "#A89491"];
let colors23 = ["#2A272C", "#E6C2C0", "#CC8F75", "#E1A69F", "#48403D", "#A28471", "#191312", "#CCC3BD", "#A89491", "#432C24"];
let colors24 = ["#CCC3BD", "#EFE6E2", "#C5B09F", "#3F3236", "#2A272C", "#A89491", "#E1A69F", "#432C24", "#AD666A", "#191312"];
let colors25 = ["#64757E", "#A48151", "#E4EDF2", "#090707", "#968A7D", "#0A1929", "#D2A979", "#1D1A11", "#3E3120", "#000410"];
let colors26 = ["#968A7D", "#1D1A11", "#00132A", "#A48151", "#9DB2BD", "#E4EDF2", "#3E3120", "#CACCCD", "#000410", "#5C5A52"];
let colors27 = ["#A48151", "#103347", "#5C5A52", "#3E3120", "#D2A979", "#968A7D", "#00132A", "#071215", "#090707", "#D79D54"];
let colors28 = ["#DF4E0A", "#B21704", "#EEA010", "#BD610A", "#303B52", "#B23E08", "#5E1F06", "#537C0B", "#A0663E", "#6FAD9E"];
let colors29 = ["#F6BA11", "#E39D4B", "#9F630C", "#B21704", "#6FAD9E", "#F1C55D", "#BD610A", "#303B52", "#C37D0E", "#E5870E"];
let colors30 = ["#EEA010", "#DF4E0A", "#B21704", "#537C0B", "#F4E5C7", "#F1C55D", "#B69145", "#E39D4B", "#EED198", "#6FAD9E"];
let colors31 = ["#10AC4B", "#E2BCB1", "#53A408", "#B2C12B", "#EBDEA3", "#20C282", "#222124", "#C58C2D", "#274FAA", "#0B682D"];
let colors32 = ["#222124", "#E7C02C", "#20C282", "#EBDEA3", "#4C3033", "#B2C12B", "#E2B07F", "#0B682D", "#54A243", "#274FAA"];
let colors33 = ["#A6B996", "#4C3033", "#E7C02C", "#0B682D", "#20C282", "#506431", "#F6F4F2", "#8F7791", "#B2C12B", "#EBDEA3"];
let paleta = [colors1, colors2, colors3, colors4, colors5, colors6, colors7, colors8, colors9, colors10, colors11, colors12, colors13, colors14, colors15, colors16, colors17, colors18, colors19, colors20, colors21, colors22, colors23, colors24, colors25, colors26, colors27, colors28, colors29, colors30, colors31, colors32, colors33];
const CYCLE = 150;
let clusters = [];
let hulls = [];
let graphics = [];
let grxy = [];
let img;
let WIDTH = window.innerWidth;
let HEIGHT = window.innerHeight;
let sz = Math.min(WIDTH, HEIGHT);
let angleSepMin, angleSepMax, angleStepMin, angleStepM;
let alpha = 100;
let c, pc = -1;
let palette;
let COLS;
let rndN, R;
let tokenData = genTokenData(248);
let tkid = tokenData.tokenId;
let seed = parseInt(tokenData.hash.slice(0, 16), 16)
let hu = 1;
let fpoints = [];
let strmove = false;
let stopmov = false;
let mk;
let rdhow = sz;
let rddir;

function setup() {
    
    //noLoop();
	createCanvas(sz, sz);
    R = new Random(seed)
    img = createGraphics(sz, sz);
    let rndS = R.random_int(0, 3);
    let size = sz;
    rndN = R.random_int(6, 10);
    mk = createGraphics(sz, sz);
    rddir = R.random_int(0, 2);
    pixelDensity(1);

    if (tkid % 2 == 0) {
        COLS = paleta[int(random(0, paleta.length))];
    } else {
        let colArr = [];
        for (t = 0; t < 10; t++) {
            colArr.push(R.random_choice(paleta)[R.random_int(0, 9)]);
        }
        COLS = colArr
    }
    palette = COLS;

    for (let i = 0; i < width * height * 5 / 100; i = i + 1) {
        fpoints.push({ x: R.random_num(0, width), y: R.random_num(0, height) });
    }

    let points = [];
    for (let i = 0; i < 5000; i++) {
        points.push(createVector(width / 2 + R.random_num(-size / 2, size / 2), height / 2 + R.random_num(-size / 2, size / 2)));
    }

    clusters = divide(points);
    hulls = [convexHull(clusters[0]), convexHull(clusters[1])];
    let s = 30;
    if (rndS == 0) { s = 40; } else if (rndS == 1) { s = 50; }
    for (let x = s / 2; x < width - s / 2; x += s) {
        for (let y = s / 2; y < height - s / 2; y += s) {
            createblocks(x, y);
        }
    }
    //let rdnSu = R.random_int(0, 1);
    //if (rdnSu == 1) shuffleArray(hulls);
    divRect(0, 0, width, height, rndN, rndN);
}

function draw() {   

    background("#ffffff");
    stroke("#A2A3A5");
    for (let fp of fpoints) {
        strokeWeight(1);
        point(fp.x, fp.y);
    }

    let rdhl = 0;

    mk.clear();
    
    for (let th = 0; th < hulls.length; th++) {
        if (hulls[th].length > 3) {
            mk.beginShape();
            for (let p of hulls[th]) {
                if (strmove && !stopmov) {
                    frameRate(60);
                    if (frameCount % 2 == 0) rdhow = sz - frameCount;
                    if (p.x > rdhow) {
                        rdhl = getNoiseVal(p.x, p.y, lerp(p.x, p.y, 0.5));
                    } else {
                        rdhl = 0;
                    }
                    switch (rddir) {
                        case 0:
                            vertex(p.x + rdhl, p.y + rdhl);
                            break;
                        case 1:
                            vertex(p.x, p.y + rdhl);
                            break;
                        case 2:
                            vertex(p.x + rdhl, p.y);
                            break;
                    }
                } else {
                    vertex(p.x, p.y);
                }
            }
            mk.endShape(CLOSE);
            if (th == hu) { hu++;  }
        }
    }
    if (frameCount > 5) strmove = true;

    imgClone = img.get();
    imgClone.mask(mk.get());

    image(imgClone, 0, 0);
}

function keyPressed() {
    if (key == ' ') {
        stopmov=true;
    }
    if (key == 'c') {
        stopmov = false;
    }
    if (key == '0') {
        rddir = 0;
    }
    if (key == '1') {
        rddir = 1;
    }
    if (key == '2') {
        rddir = 2;
    }
}

function getNoiseVal(x, y, k) {
    const ns = 0.005;
    const no = frameCount / 100;
    return (noise(x * ns + no, y * ns + no) - 0.5) * k;
}

function divRect(cox, coy, w, h, dxNum, dyNum)
{
	const twoCellVolume = 0.35;
	const xSpan = w / dxNum;
	const ySpan = h / dyNum;
	
	let drawnFrag = [];
	for(let yi = 0; yi < dyNum; yi++)
	{
		drawnFrag[yi] = [];
		for(let xi = 0; xi < dxNum; xi++)
		{
			drawnFrag[yi][xi] = false;
		}
	}
	
	for(let yi = 0; yi < dyNum; yi++)
	for(let xi = 0; xi < dxNum; xi++)
	{
		let cx = cox + (xi + 0.5) * xSpan;
		let cy = coy + (yi + 0.5) * ySpan;
		let uw = xSpan;
		let uh = ySpan;
		
		if(drawnFrag[yi][xi] == true)continue;
		
        if (R.random_dec() < twoCellVolume  && xi != dxNum - 1  && yi != dyNum - 1)
		{
			let isHori;
			if(xi == dxNum - 1)isHori = false;
			else if(yi == dyNum - 1)isHori = true;
			else if(drawnFrag[yi][xi + 1] == true)isHori = false;
            else if (R.random_dec() > 0.5) isHori = false;
			else isHori = true;
			if(isHori)
			{
				cx += xSpan* 0.5;
				uw *= 2;
				drawnFrag[yi][xi + 1] = true;
			}else
			{
				cy += ySpan* 0.5;
				uh *= 2;
				drawnFrag[yi + 1][xi] = true;
			}
		}
		
		const c = COLS;
		drawUnit(cx, cy, uw, uh, c);
		drawnFrag[yi][xi] = true;
	}
}

const UNITFUNCS = [stripe, triPattern, kiba, kuchibashi, recursiveRect, drawStar, genParcattern, makePanel, flower];

function drawUnit(cx, cy, w, h, cArr)
{
    const fn = R.random_int(0, UNITFUNCS.length - 1);//int(R.random_dec() * UNITFUNCS.length);
    UNITFUNCS[fn](cx, cy, w, h, cArr);
	
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

function drawStar(cx, cy, w, h, cArr) {
    img.push();
    img.curveTightness(0);
    img.stroke(cArr[0]);
    //img.fill(cArr[R.random_int(0, floor(cArr.length/2))]);
    img.fill(cArr[0]);
    img.rect(cx, cy, w, h);
    let theta = random(TWO_PI);
    let pos = createVector(cx, cy)
    img.noStroke();
    img.fill(cArr[R.random_int(floor(cArr.length / 2) + 1, cArr.length-1)]);
    img.beginShape();
    for (let i = 0; i < 8; i++) {
        let v = p5.Vector.fromAngle(theta, h/2).add(pos);
        curveVertex(v.x, v.y);
        theta += 2 * TWO_PI / 5;
    }
    img.endShape();
    img.pop();
    //console.log(cArr[R.random_int(0, floor(cArr.length / 2))] + ' ' + cArr[R.random_int(floor(cArr.length / 2) + 1, cArr.length - 1)]);
}

function genParcattern(cx, cy, w, h, cArr) {
    circNum = R.random_int(4, 10);
    blockSize = w;
    let bgClr = cArr[0];
    img.stroke(bgClr);
    img.fill(bgClr);
    img.rect(cx, cy, w, h);

    img.strokeCap(SQUARE);

    for (var y = blockSize / 2; y < h + blockSize / 2; y += blockSize) {
        for (var x = blockSize / 2; x < w + blockSize / 2; x += blockSize) {
            img.push();
            img.noStroke();
            img.translate(cx, cy);
            img.rotate(HALF_PI * Math.round(R.random_num(0, 4)));

            for (var i = circNum; i > 0; --i) {
                var diam = blockSize * 2 * i / (circNum + 1);
                if (i < 2) { img.fill(bgClr); } else { img.fill(cArr[separateIdx(i - 1, circNum + 1)]); }
                img.arc(-blockSize / 2, -blockSize / 2, diam, diam, 0, HALF_PI);
            }

            for (var i = circNum; i > 0; --i) {
                var diam = blockSize * 2 * i / (circNum + 1);
                if (i < 2) { img.fill(bgClr); } else { img.fill(cArr[separateIdx(i - 1, circNum + 1)]); }
                img.arc(-blockSize / 2 + blockSize, -blockSize / 2 + blockSize, diam, diam, PI, PI + HALF_PI);
            }
            img.pop();
        }
    }
}

function separateIdx(idx, length) {
    return Math.floor(Math.abs(idx - (length - 1) / 2));
}

function recursiveRect(x, y, d, g, cArr) {
    img.push();
    img.rectMode(CENTER);
    img.stroke(cArr[0]);
    img.fill(cArr[0]);
    img.rect(x, y, d, g);
    img.drawingContext.clip();
    circularGraphics(x, y, d, cArr);
    img.pop();
}

function circularGraphics(cx, cy, rMax, cArr) {
    let colors = cArr;

    let a = R.random_int(1, 5);
    let b = R.random_int(1, 5);
    let c = R.random_int(1, 5);
    let d = R.random_int(1, 5);

    angleSepMin = min(a, b);
    angleSepMax = max(a, b);

    angleStepMin = min(c, d);
    angleStepMax = max(c, d);
    let rSep = R.random_int(3, 5);
    img.stroke(cArr[0]);
    // randomSeed(0);
    img.push();
    img.translate(cx, cy);
    for (let r = rMax / 2; r > 0; r -= rMax / rSep) {
        let r2 = r - rMax / 10;
        let isFirstBigger = R.random_dec() > 0.5;
        let startAngle = 0; //random(360);
        let angleNum = R.random_int(angleSepMin, angleSepMax) * R.random_int(angleStepMin, angleStepMax);
        let angleWidth = (2 * PI * (isFirstBigger ? r : r2)) / angleNum;
        let angleStep = 360 / angleNum;
        let f = R.random_int(2, 5);
        img.drawingContext.shadowColor = color(0, 0, 0, 10);
        img.drawingContext.shadowBlur = width / 20;
        angleWidth / 3;
        if (r < rMax / 2 * 0.8) img.drawingContext.shadowBlur = 0;

        img.push();
        img.fill(cArr[0]);
        img.stroke(cArr[0]);
        img.rect(0, 0, r * 2);

        img.drawingContext.clip();
        //img.drawingContext.shadowBlur = angleWidth / 3;

        for (let angle = startAngle; angle < startAngle + 360; angle += angleStep) {
            let x = cos(angle) * (isFirstBigger ? r : r2);
            let y = sin(angle) * (isFirstBigger ? r : r2);
            for (let e = 1; e > 0; e -= 1 / f) {
                img.push();
                img.translate(x, y);
                img.rotate(angle - 90);
                img.scale(e);
                //img.strokeWeight(1 / e);
                //img.stroke(0, 0, 0, alpha);
                img.noStroke();
                img.fill(R.random_choice(palette));
                img.rect(0, 0, angleWidth, angleWidth);
                img.pop();
            }
        }

        startAngle = R.random_num(0, 360);
        angleNum = R.random_int(angleSepMin, angleSepMax) * R.random_int(angleStepMin, angleStepMax);
        angleWidth = (2 * PI * (isFirstBigger ? r2 : r)) / angleNum;
        angleStep = 360 / angleNum;
        f = R.random_int(2, 5);
        for (let angle = startAngle; angle < startAngle + 360; angle += angleStep) {
            let x = cos(angle) * (isFirstBigger ? r2 : r);
            let y = sin(angle) * (isFirstBigger ? r2 : r);
            for (let e = 1; e > 0; e -= 1 / f) {
                img.push();
                img.translate(x, y);
                img.rotate(angle - 90);
                img.scale(e);
                //img.strokeWeight(1 / e);
                //img.stroke(0, 0, 0, alpha);
                img.noStroke();
                let c1 = pc;
                while (c1 == pc) {
                    c1 = R.random_choice(colors);
                }
                img.fill(c1);
                pc = c1;
                img.rect(0, 0, angleWidth, angleWidth);
                img.pop();
            }
        }
        img.pop();
    }
    img.pop();
    //graphics.push(img2)
    //graphics.push({ obj: img2, x: cx, y: cy });
}

function triPattern(cx, cy, w, h, cArr)
{
    //let img4 = createGraphics(w, h);
    img.stroke(cArr[0]);
    img.rectMode(CENTER);
    img.push();
    img.translate(cx, cy);
    //img.fill(R.random_choice(cArr));
    img.fill(cArr[0]);
    img.rect(0, 0, w, h);
    img.push();
    img.drawingContext.clip();
    const xSpan = w / R.random_int(2, 4);
    const ySpan = h / R.random_int(2, 4);
	let c = 0;
	for(let y = -h / 2; y < h / 2; y += ySpan)
	{
		const xOff = c % 2 == 0 ? 0 : xSpan / 2 * 0;
		for(let x = -w / 2; x < w / 2; x += xSpan)
		{
            img.fill(R.random_choice(cArr));
            img.triangle(x + xOff, y, x + xSpan + xOff , y, x + xSpan / 2 + xOff , y + ySpan);
		}
		c++;
	}
	
    img.pop();
    img.pop();
}


function flower(x, y, w, h, cArr) {
    img.push();
    let c1 = cArr[R.random_int(1, floor(cArr.length / 2))];
    let c2 = cArr[R.random_int(floor(cArr.length / 2) + 1, cArr.length - 1)];
    img.fill(cArr[0]);
    img.rect(x, y, w, h);
    img.translate(x, y);
    //img.rotate(a);
    let num = R.random_int(10, 16);
    img.fill(c1);
    for (let i = 0; i < num; i++) {
        img.rotate(TAU / num);
        img.ellipse(w * 0.32, 0, w * 0.35, (w / num) * 1.8);
    }
    img.fill(c2);
    img.circle(0, 0, w * 0.4);
    img.pop();
}

function makePanel(x, y, w, h, cArr) {
    img.push();
    img.noStroke();
    img.translate(x, y);
    img.fill(cArr[0]);
    img.rect(0, 0, w, h);
    let d = sqrt(sq(w) + sq(h)) * 0.5;
    let n1 = R.random_int(4, 8);
    let thetaStep = TAU / n1;
    let theta0 = R.random_num(0, TAU);
    let rot = R.random_num(-1, 1) * 0.04;
    let thetaCut = random([1 / 3, 1 / 2, 2 / 3]);
    let thetaFlip = 10;
    let col1 = cArr[R.random_int(0, floor(cArr.length / 2))];
    let col2 = cArr[R.random_int(floor(cArr.length / 2) + 1, cArr.length - 1)]
        //img.fill(cArr[1]);
        while (d > 0) {
            for (let theta = theta0; theta < theta0 + TAU; theta += thetaStep) {
                //if (tkid % 2 == 0) {col1 = cArr[R.random_int(0, floor(cArr.length / 2))]; col2 = cArr[R.random_int(floor(cArr.length / 2) + 1, cArr.length - 1)]}
                img.fill(col1);
                img.arc(0, 0, d, d, theta, theta + thetaStep * thetaCut);
                //img.erase();
                img.fill(col2);
                img.arc(0, 0, d, d, theta + thetaStep * thetaCut, theta + thetaStep);
                img.noErase();
            }
            d -= 0.5;
            theta0 += rot;
            if (d % thetaFlip == 0) rot *= -1;
        }
    img.pop()
}

function stripe(cx, cy, w, h, cArr)
{
    //let img5 = createGraphics(w, h);
	const span = w / 5;
    img.stroke(cArr[0]);
    //img.strokeWeight(0);
    img.rectMode(CENTER);
    img.push();
    img.translate(cx, cy);
    //img.fill(R.random_choice(cArr));
    img.fill(cArr[0]);
    img.rect(0, 0, w, h);
    img.push();
    img.drawingContext.clip();
	//rotate(int(random(4)) * PI);
	
    const xSpan = w / R.random_int(2, 4);
    const ySpan = h / R.random_num(2, 3);
	const yOff = xSpan * 0.5;
    let c = 0;
    img.noStroke();
	for(let y = h; y > -h; y -= ySpan)
	{
		const cOff = c % 2 == 0 ? 0 : 1;
		for(let x = -w; x < w; x += xSpan)
		{
            img.fill(cArr[1 + cOff]);
            img.quad(x - xSpan / 2, y - ySpan / 2, x - xSpan / 2 , y + ySpan / 2, x , y + ySpan / 2 + yOff, x , y - ySpan / 2 );
            img.fill(cArr[2 + cOff]);
            img.quad(x + xSpan / 2 , y - ySpan / 2, x + xSpan / 2 , y + ySpan / 2, x , y + ySpan / 2 + yOff, x , y - ySpan / 2);
		}
		c++;
	}
	
    img.pop();
    img.pop();
    //graphics.push(img5);
    //graphics.push({ obj: img5, x: cx, y: cy });
}

function kiba(cx, cy, w, h, cArr)
{
    const span = w / R.random_int(3, 5);
	const kibaH = h * 0.4;
    //img.noStroke();
    img.stroke(cArr[0]);
    img.rectMode(CENTER);
    img.push();
    img.translate(cx, cy);
    img.rotate(R.random_int(0, 2) * PI);
    img.fill(cArr[0]);
    img.rect(0, 0, w, h);
    img.drawingContext.clip();
    img.fill(cArr[1]);
    img.noStroke();
	for(let x = -w / 2; x < w /2; x += span)
	{
        img.triangle(x + span / 2, -kibaH * 0.5, x, h / 2, x + span, h / 2 );
	}

    img.pop();
}

function kuchibashi(cx, cy, w, h, cArr)
{
    img.noStroke();
    img.rectMode(CENTER);
    img.push();
	
    img.translate(cx, cy);
    img.rotate(R.random_int(0, 2) * PI);
    img.fill(cArr[0]);
    img.rect(0, 0, w, h);
    img.fill(cArr[1]);
    img.triangle(-w / 2, -h / 2, w / 2, 0, -w / 2, 0);
	
    img.fill(cArr[2]);
    img.triangle(-w / 2, h / 2, w / 2, 0, -w / 2, 0);
	
    if (w == h && R.random_dec() > 0.5)
	{
		eye(- w, 0, w, h, cArr);
	}
    img.pop();
}

function eye(cx, cy, w, h, cArr) {
    const s = min(w, h) * R.random_num(0.4, 0.7);
    img.noStroke();
    img.rectMode(CENTER);
    img.push();
    img.translate(cx, cy);
    //rotate(int(random(4)) * PI);
    //img.fill(R.random_choice(cArr));
    img.fill(cArr[0]);
    img.rect(0, 0, w, h);
    img.fill(255);
    const offset = (min(w, h) - s) * R.random_num(0.1, 0.4) * 0;
    img.translate(offset, offset);
    img.circle(0, 0, s);
    img.fill(R.random_choice(cArr));
    img.circle(0, 0, s * 0.75);
    img.fill(0);
    img.circle(0, 0, s * 0.5);
    img.pop();
}

function mouseReleased() {
    createblocks(mouseX, mouseY);
}

function createblocks(x, y) {
    let p = createVector(x, y);
    let argmin = -1;
    let minDist = width * height;

    for (let i = 0; i < clusters.length; i++) {
        for (let q of clusters[i]) {
            let d = distSquared(p, q);
            if (d < minDist) {
                argmin = i;
                minDist = d;
                continue;
            }
        }
    }

    if (hulls[argmin].length > 5) {
        let clu = clusters.splice(argmin, 1)[0];
        let newClusters = divide(clu);
        clusters = [...clusters, ...newClusters];
        hulls.splice(argmin, 1);
        hulls = [...hulls, convexHull(newClusters[0]), convexHull(newClusters[1])];
    }

    return false;
}

function divide(points) {
    let clusters = [];

    let centroids = [];
    for (let i = 0; i < 2; i++) {
        let c;
        do {
            c = R.random_choice(points);
        } while (centroids.indexOf(c) != -1)
        centroids.push(c);
        clusters.push([]);
    }

    // assign clusters
    for (let p of points) {
        let argmin = 0;
        let minDist = distSquared(p, centroids[0]);
        for (let i = 1; i < 2; i++) {
            let d = distSquared(p, centroids[i]);
            if (d < minDist) {
                minDist = d;
                argmin = i;
            }
        }
        clusters[argmin].push(p);
    }

    return clusters;
}

function convexHull(points) {
    points.sort((p, q) => p.x - q.x);
    let hull = [];
    let i = 0;
    let endPoint;
    let pointOnHull = points[0];
    do {
        hull.push(pointOnHull);
        endPoint = points[0];
        for (let j = 0; j < points.length; j++) {
            let p = p5.Vector.sub(endPoint, pointOnHull);
            let q = p5.Vector.sub(points[j], pointOnHull);
            if (endPoint.equals(pointOnHull) || (p.cross(q)).z < 0) {
                endPoint = points[j];
            }
        }
        i++;
        pointOnHull = endPoint;
    } while (!endPoint.equals(points[0]));
    return hull;
}

function distSquared(p, q) {
    return sq(p.x - q.x) + sq(p.y - q.y);
}

class Random {
    constructor(e) {
        this.seed = e
    }
    random_dec() {
        return this.seed ^= this.seed << 13, this.seed ^= this.seed >> 17, this.seed ^= this.seed << 5, (this.seed < 0 ? 1 + ~this.seed : this.seed) % 1e3 / 1e3
    }
    random_num(e, r) {
        return e + (r - e) * this.random_dec()
    }
    random_int(e, r) {
        return Math.floor(this.random_num(e, r + 1))
    }
    random_choice(e) {
        return e[Math.floor(this.random_num(0, .99 * e.length))]
    }
}


function genTokenData(projectNum) {
    let data = {};
    let hash = "0x";
    for (var i = 0; i < 64; i++) {
        hash += Math.floor(Math.random() * 16).toString(16);
    }
    data.hash = hash;
    data.tokenId = (projectNum * 1000000 + Math.floor(Math.random() * 1000)).toString();
    return data;
}